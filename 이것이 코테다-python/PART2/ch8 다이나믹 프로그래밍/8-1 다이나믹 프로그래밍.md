## 중복되는 연산을 줄이자.
- **다이나믹 프로그래밍**
    - = 동적 계획법
    - 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야한다.
        - 여기서 어떤 문제는 **메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가** 시키는 방법
    - 사용하기 위한 문제의 조건
        - 큰 문제를 작은 문제로 나눌 수 있다.
        - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
    - 기법
        - 메모이제이션
            - = 캐싱
            - 한번 구한 결과를 메모리 공간에 메모해두고,
            - 같은 식을 다시 호출하면 메모한 결과를 그대로 가져로는 기법
- 예시 - 피보나치 수열

- 점화식을 이용한 재귀적 풀이
    - 시간 복잡도
        - O(2<sup>N</sup>)


```python
def fibo(n):
    if n == 1 or n == 2:
        return 1
    return fibo(n-1) + fibo(n-2)
```

- 다이나믹 프로그래밍을 이용한 재귀적 풀이
    - 시간 복잡도
        - O(N)


```python
# 한번 계산될 결과를 메모이제이션하기 위한 리스트 초기화
d = [0]*100

def fibo(n):
    if n == 1 or n == 2:
        return 1
    if d[n] != 0:
        return d[n]
    d[n] = fibo(n-1) + fibo(n-2)
    return d[n]
```

- 탑다운 방식 - 하향식
    - 재귀함수를 이용한 다이나믹 프로그래밍 소스코드 작성 방식
    - 큰문제를 해결하기 위해 작은 문제를 호출
- 보텀업 방식 - 상향식
    - 단순히 반복문을 이용하여 소스코드를 작성하는 방식
    - 작은 문제부터 차근차근 답을 도출
